/*
===================================================
__________________________________________________
| ___ \| ___ \|  _  || | | |  |  ___|\ \ / /|  ___| 
| |_/ /| |_/ /| | | || | | |  | |__   \ V / | |__   
|  __/ |    / | | | || | | |  |  __|  /   \ |  __|  
| |    | |\ \ \ \_/ /\ \_/ /_ | |___ / /^\ \| |___  
\_|    \_| \_| \___/  \___/(_)\____/ \/   \/\____/ 

Decomplied Raw Data analysis By ZION
======================================================

*/




int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  // => Intilization of the Prov.Exe with the following parameters !
  /* 
  _In_ HINSTANCE hInstance, // => A handle to the current instance of the application.
  _In_ HINSTANCE hPrevInstance, // handle to the previous instance of the application
  _In_ LPSTR     lpCmdLine,
  _In_ int       nCmdShow
);
*/
  HWND v5; // eax@8
  WNDCLASSW WndClass; // [sp+8h] [bp-28h]@7

  if ( CreateMutexW(0, 1, L"AireSpiderWPS") && GetLastError() != 183 ) // => 
    // ok so createmutex crates a thing called a mutex object
    // Mutex object creates mutiple threads and synchroizes them
  {
    if ( sub_4036B0() || !sub_403530() )  // => Now these two function :((()))
    {
      /*==============================================================================*/
      WndClass.style = 3;
      WndClass.lpfnWndProc = (WNDPROC)sub_403320;
      WndClass.cbClsExtra = 0;
      WndClass.cbWndExtra = 0;
      WndClass.hInstance = hInstance;
      WndClass.hIcon = LoadIconW(0, (LPCWSTR)0x66);
      WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
      WndClass.hbrBackground = (HBRUSH)GetStockObject(13);
      WndClass.lpszMenuName = 0;
      WndClass.lpszClassName = L"AireSpiderWPS";

      /*==================================================================================*/
      if ( RegisterClassW(&WndClass) )
      {
        v5 = GetDesktopWindow();
        DialogBoxParamW(hInstance, (LPCWSTR)0x67, v5, DialogFunc, 0);
        return 0;
      }
    }
    else if ( !sub_403730() )
    {
      MessageBoxW(0, L"Failed to elevate user privileges to administrator", 0, 0x10u);
      return 0;
    }
  }
  else
  {
    MessageBoxW(0, L"prov.exe is already running", 0, 0x10u);
  }
  return 0;
}


BOOL sub_403530()
{
  HANDLE v0; // eax@1 // => v0 is a resource loaded into memory
  DWORDLONG v1; // rax@2 // => v1 is a 32bit value
  int TokenInformation; // Varible for tokens ?
  BOOL IsMember; // [sp+10h] [bp-180h]@1
  DWORD ReturnLength; // ReturnLength value is a 32 bit value
  HANDLE DuplicateTokenHandle; // Resource crated to deplicate tokens
  HANDLE TokenHandle; // Resource crated for security tokens
  struct _OSVERSIONINFOEXW VersionInformation; // [sp+20h] [bp-170h]@2
  char pSid; // [sp+140h] [bp-50h]@8

  IsMember = 0;
  TokenHandle = 0;
  DuplicateTokenHandle = 0;
  ReturnLength = 0;
  v0 = GetCurrentProcess(); // Gets the Current Process :(
  if ( OpenProcessToken(v0, 0xAu, &TokenHandle) )
  // if OpenProcess has a handle, a access token and a pointer to a handle that has the newly opened access token
  {
    memset(&VersionInformation, 0, 0x11Cu); // 
    VersionInformation.dwOSVersionInfoSize = 284; // ?
    VersionInformation.dwMajorVersion = 6; // ? 
    v1 = VerSetConditionMask(0i64, 2u, 1u); // => v1 is now a 64 bit value set of values for operating systems versonis
    // IMPORTANT: 0i64 is a 64 bit integer to be used as a pointer to OSVERSIONINFOEX
    // IMPORTANT: 2U is an unsigned integer
    // IMPORTANT: 1u is an unsigned integer

/*-----------------------------------------------------------------------------------------------------*/
//>                                               THIS SEEMS TO BE WITH SECURITY TOKENS
    if ( (!VerifyVersionInfoW(&VersionInformation, 2u, v1)
       || GetTokenInformation(TokenHandle, (TOKEN_INFORMATION_CLASS)18, &TokenInformation, 4u, &ReturnLength) 
       /*^  If the Verson Infomation is verfied than Get the tokeninfo in relation to the*/
       && (TokenInformation != 3
        || GetTokenInformation(TokenHandle, TokenPrivileges|0x10, &DuplicateTokenHandle, 4u, &ReturnLength)))
      && (DuplicateTokenHandle || DuplicateToken(TokenHandle, SecurityIdentification, &DuplicateTokenHandle)) )
    {
      ReturnLength = 68;
      if ( CreateWellKnownSid(WinBuiltinAdministratorsSid, 0, &pSid, &ReturnLength) )
        CheckTokenMembership(DuplicateTokenHandle, &pSid, &IsMember);
    }
  }
/*----------------------------------------------------------------------------------------------------------*/
  if ( TokenHandle )
  {
    CloseHandle(TokenHandle);
    TokenHandle = 0;
  }
  if ( DuplicateTokenHandle )
    CloseHandle(DuplicateTokenHandle);
  return IsMember;
}

BOOL sub_4036B0()
{
  PSID pSid; // [sp+4h] [bp-14h]@1
  BOOL IsMember; // [sp+8h] [bp-10h]@1
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [sp+Ch] [bp-Ch]@1

  IsMember = 0;
  pSid = 0;
  *(_DWORD *)&pIdentifierAuthority.Value[0] = 0;
  *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
  if ( AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &pSid) )
    CheckTokenMembership(0, pSid, &IsMember);
  if ( pSid )
    FreeSid(pSid);
  return IsMember;
}



DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  void (__stdcall *v1)(HWND, LPCWSTR); // edi@1
  signed int v2; // edi@15
  char v3; // dl@16
  wchar_t *v4; // eax@17
  wchar_t *v5; // esi@22
  int v6; // edx@23
  wchar_t v7; // cx@24
  int v8; // ebx@25
  size_t v9; // edi@25
  signed int v10; // esi@34
  char v11; // ST36_1@37
  wchar_t *v12; // ST1C_4@37
  int v13; // ecx@37
  char v14; // ST36_1@40
  __int16 v15; // bx@43
  _DWORD *v16; // ecx@43
  int v17; // edi@43
  wchar_t *v18; // edx@46
  unsigned int v19; // esi@46
  int v20; // ebx@47
  int v21; // eax@48
  wchar_t *v22; // eax@56
  char *v23; // edx@56
  signed int v24; // esi@58
  signed int v25; // esi@66
  wchar_t *v26; // ST20_4@68
  int v27; // ecx@70
  char v29; // [sp+18h] [bp-B2Eh]@43
  char v30; // [sp+19h] [bp-B2Dh]@34
  signed int v31; // [sp+1Ah] [bp-B2Ch]@15
  int v32; // [sp+1Eh] [bp-B28h]@46
  wchar_t *v33; // [sp+22h] [bp-B24h]@46
  int v34; // [sp+26h] [bp-B20h]@46
  int v35; // [sp+2Ah] [bp-B1Ch]@46
  int v36; // [sp+2Eh] [bp-B18h]@46
  int v37; // [sp+32h] [bp-B14h]@46
  __int16 v38; // [sp+36h] [bp-B10h]@43
  char v39; // [sp+38h] [bp-B0Eh]@43
  WCHAR String; // [sp+136h] [bp-A10h]@37
  wchar_t v41; // [sp+936h] [bp-210h]@68

  dword_41CF80 = GetTempPathW(0x100u, &Buffer);
  sub_403450(L"Checking Windows version...");
  v1 = (void (__stdcall *)(HWND, LPCWSTR))SetWindowTextW;
  SetWindowTextW(hWnd, L"Checking Windows version...");
  if ( !(unsigned __int8)Verfification_Routine() )
  {
    sub_403450(L"This version of Windows is not supported. Please follow the manual steps to configure your wireless access");
    MessageBoxW(
      wParam,
      L"This version of Windows is not supported. Please follow the manual steps to configure your wireless access",
      L"Error",
      0x10u);
LABEL_74:
    sub_403450(L"Configuration Failed");
    v1(hWnd, L"Configuration Failed");
    PostMessageW(HWND_BROADCAST, 0x28u, (WPARAM)wParam, 1);
    EnableWindow(dword_41D530, 1);
    return 0;
  }
  sub_403450(L"Checking User Privilege ...");
  SetWindowTextW(hWnd, L"Checking User Privilege ...");
  CoInitialize(0);
  CoInitializeSecurity(0, -1, 0, 0, 1u, 3u, 0, 0, 0);
  sub_403450(L"Loading wireless configurations ...");
  SetWindowTextW(hWnd, L"Loading wireless configurations ...");
  sub_4037F0();
  Sleep(0x12Cu);
  if ( !(unsigned __int8)sub_404290() && !byte_41D546 )
  {
    sub_403450(L"No valid wireless configuration is found. Please contact your IT staff");
    MessageBoxW(wParam, L"No valid wireless configuration is found. Please contact your IT staff", L"Error", 0x10u);
    goto LABEL_74;
  }
  sub_403450(L"Searching wireless adapters ...");
  SetWindowTextW(hWnd, L"Searching wireless adapters ...");
  Sleep(0x12Cu);
  if ( sub_401450() )
  {
    sub_403450(L"Unable to query Windows for wireless adapters");
LABEL_10:
    sub_403450(L"No wireless adapter identified. Please check if one is plugged-in and enabled");
    MessageBoxW(
      wParam,
      L"No wireless adapter identified. Please check if one is plugged-in and enabled",
      L"Error",
      0x10u);
    goto LABEL_74;
  }
  if ( !*(_DWORD *)dword_41D52C )
  {
    sub_403450(L"No wireless adapter found");
    goto LABEL_10;
  }
  sub_403450(L"Preparing configuration...");
  SetWindowTextW(hWnd, L"Preparing configuration...");
  if ( byte_41D546 )
  {
    if ( byte_41D544 )
      sub_403450(L"-clearall specified, All profiles will be deleted");
    sub_4015A0(0);
  }
  else
  {
    Sleep(0x12Cu);
    v2 = 0;
    v31 = 0;
    do
    {
      v3 = *((_BYTE *)&dword_41D288 + v2);
      if ( !v3 )
        break;
      v4 = *(wchar_t **)&dword_41D188[2 * v2];
      if ( !v4 )
        break;
      if ( v3 == 2 || v3 == 1 )
      {
        sub_4015A0(*(_DWORD *)&dword_41D188[2 * v2]);
      }
      else if ( v3 == 3 )
      {
        if ( byte_41D547 )
        {
          v5 = *(wchar_t **)&dword_41D188[2 * v2];
        }
        else
        {
          v6 = (int)(v4 + 1);
          do
          {
            v7 = *v4;
            ++v4;
          }
          while ( v7 );
          v8 = ((signed int)v4 - v6) >> 1;
          v9 = v8 + dword_41CF80;
          if ( v8 + dword_41CF80 > 0x100 )
            v9 = 256;
          v5 = (wchar_t *)operator new(2 * (v9 + 1));
          wcsncpy(v5, &Buffer, dword_41CF80);
          wcsncpy(&v5[dword_41CF80], *(const wchar_t **)&dword_41D188[2 * v31], v8);
          v5[v9] = 0;
          v2 = v31;
        }
        if ( !(unsigned __int8)sub_402550(v5) )
        {
          ShowWindow(wParam, 0);
          sub_403450(L"Your personal certificate has been created. Click OK to install it.\nCertificate Import Wizard will be launched. Please accept the default settings until it is finished.");
          MessageBoxW(
            wParam,
            L"Your personal certificate has been created. Click OK to install it.\n"
             "Certificate Import Wizard will be launched. Please accept the default settings until it is finished.",
            L"Info",
            0x40u);
          _wsystem(v5);
          ShowWindow(wParam, 5);
        }
        if ( !byte_41D547 )
          operator delete(v5);
      }
      v31 = ++v2;
    }
    while ( v2 < 32 );
  }
  v30 = 1;
  v10 = 0;
  do
  {
    if ( !(&dword_41D2A8)[2 * v10] )
      break;
    if ( *((_BYTE *)&dword_41D288 + v10) == 2 )
    {
      v11 = sub_4016B0((&dword_41D2A8)[2 * v10]);
      v12 = *(wchar_t **)&dword_41D188[2 * v10];
      sub_401000(v13, &String);
      sub_403450(&String);
      SetWindowTextW(hWnd, &String);
      if ( v11 )
        v30 = 0;
    }
    if ( *((_BYTE *)&dword_41D288 + v10) == 5 )
    {
      v14 = sub_401FC0(*(_DWORD *)&dword_41D188[2 * v10], (&dword_41D2A8)[2 * v10]);
      sub_401000(*(_DWORD *)&dword_41D188[2 * v10], &String);
      sub_403450(&String);
      SetWindowTextW(hWnd, &String);
      if ( v14 )
        v30 = 0;
    }
    ++v10;
  }
  while ( v10 < 32 );
  v15 = 0;
  v29 = 0;
  v38 = 0;
  memset(&v39, 0, 0xFEu);
  v16 = (_DWORD *)dword_41D52C;
  v17 = 0;
  while ( (&dword_41D2A8)[2 * v17] )
  {
    if ( *((_BYTE *)&dword_41D288 + v17) == 2 )
    {
      v18 = *(wchar_t **)&dword_41D188[2 * v17];
      v34 = 0;
      v35 = 0;
      v32 = 0;
      v33 = v18;
      v36 = 1;
      v37 = 1;
      v19 = 0;
      v29 = 0;
      if ( *v16 > 0u )
      {
        v20 = 0;
        while ( 1 )
        {
          v21 = WlanConnect(dword_41D528, &v16[v20 + 2], &v32, 0);
          v16 = (_DWORD *)dword_41D52C;
          if ( !v21 )
            break;
          ++v19;
          v20 += 133;
          if ( v19 >= *(_DWORD *)dword_41D52C )
            goto LABEL_52;
        }
        v29 = 1;
LABEL_52:
        v15 = 0;
      }
      if ( v29 )
      {
        v22 = *(wchar_t **)&dword_41D188[2 * v17];
        v23 = (char *)((char *)&v38 - (char *)v22);
        do
        {
          v16 = (_DWORD *)*v22;
          *(wchar_t *)((char *)v22 + (_DWORD)v23) = (unsigned __int16)v16;
          ++v22;
        }
        while ( (_WORD)v16 != v15 );
        break;
      }
    }
    if ( ++v17 >= 32 )
      break;
  }
  v24 = 0;
  do
  {
    if ( *(_DWORD *)&dword_41D188[v24] )
    {
      free(*(void **)&dword_41D188[v24]);
      *(_DWORD *)&dword_41D188[v24] = 0;
    }
    if ( (&dword_41D2A8)[v24] )
    {
      free((&dword_41D2A8)[v24]);
      (&dword_41D2A8)[v24] = 0;
    }
    v24 += 2;
  }
  while ( v24 < 64 );
  if ( dword_41D528 )
    WlanCloseHandle(v16, dword_41D528, 0);
  v25 = 0;
  do
  {
    if ( *((_BYTE *)&dword_41D288 + v25) == 4 )
    {
      v26 = *(wchar_t **)&dword_41D188[2 * v25];
      sub_401000(v16, &v41);
      _wsystem(&v41);
    }
    ++v25;
  }
  while ( v25 < 32 );
  CoUninitialize();
  if ( v30 && !byte_41D545 && !byte_41D546 )
  {
    sub_403450(L"None of your wireless adapter can be configured. It's likely that you need a newer wireless adapter or its driver.");
    MessageBoxW(
      wParam,
      L"None of your wireless adapter can be configured. It's likely that you need a newer wireless adapter or its driver.",
      L"Error",
      0x10u);
    v1 = (void (__stdcall *)(HWND, LPCWSTR))SetWindowTextW;
    goto LABEL_74;
  }
  if ( v29 )
  {
    sub_403450(L"You are now successfully connected to Secured Wireless network. You may now access your applicatons");
    SetWindowTextW(
      hWnd,
      L"You are now successfully connected to Secured Wireless network. You may now access your applicatons");
  }
  else
  {
    sub_401000(v27, &String);
    sub_403450(&String);
    SetWindowTextW(hWnd, &String);
  }
  EnableWindow(dword_41D530, 1);
  if ( byte_41D545 || byte_41D546 )
    PostMessageW(wParam, 0x111u, 8u, 0);
  else
    PostMessageW(HWND_BROADCAST, 0x28u, (WPARAM)wParam, 1);
  return 0;
}


int __usercall Heaven@<eax>(const unsigned __int16 *a1@<edx>, const wchar_t *a2@<ecx>, BYTE *a3)
{
  const wchar_t *v3; // ebx@1
  const wchar_t *v4; // eax@1
  const unsigned __int16 *v5; // edi@1
  int v6; // edx@1
  wchar_t v7; // cx@2
  unsigned int v8; // esi@3
  int v9; // ecx@4
  unsigned int v10; // esi@5
  char v11; // al@5
  DWORD v12; // esi@6
  BYTE *v13; // ecx@6
  HKEY hKey; // [sp+Ch] [bp-5458h]@4
  HKEY phkResult; // [sp+10h] [bp-5454h]@3
  DATA_BLOB pDataIn; // [sp+14h] [bp-5450h]@1
  int v18; // [sp+1Ch] [bp-5448h]@6
  int v19; // [sp+20h] [bp-5444h]@6
  int v20; // [sp+24h] [bp-5440h]@6
  int v21; // [sp+28h] [bp-543Ch]@6
  int v22; // [sp+2Ch] [bp-5438h]@6
  int v23; // [sp+30h] [bp-5434h]@6
  int v24; // [sp+34h] [bp-5430h]@6
  int v25; // [sp+38h] [bp-542Ch]@6
  int v26; // [sp+3Ch] [bp-5428h]@6
  int v27; // [sp+40h] [bp-5424h]@6
  __int16 v28; // [sp+44h] [bp-5420h]@6
  int v29; // [sp+48h] [bp-541Ch]@1
  DATA_BLOB pDataOut; // [sp+4Ch] [bp-5418h]@3
  char v31; // [sp+57h] [bp-540Dh]@5
  char v32; // [sp+58h] [bp-540Ch]@4
  char v33; // [sp+68h] [bp-53FCh]@5
  char v34; // [sp+69h] [bp-53FBh]@5
  char v35; // [sp+6Ch] [bp-53F8h]@5
  char v36; // [sp+70h] [bp-53F4h]@5
  char v37; // [sp+74h] [bp-53F0h]@5
  char v38; // [sp+75h] [bp-53EFh]@5
  char v39; // [sp+78h] [bp-53ECh]@5
  char v40; // [sp+7Ch] [bp-53E8h]@5
  char v41; // [sp+7Dh] [bp-53E7h]@5
  char v42; // [sp+80h] [bp-53E4h]@5
  char v43; // [sp+84h] [bp-53E0h]@5
  char v44; // [sp+88h] [bp-53DCh]@5
  char v45; // [sp+89h] [bp-53DBh]@5
  char v46; // [sp+90h] [bp-53D4h]@5
  char v47; // [sp+94h] [bp-53D0h]@5
  char v48; // [sp+A4h] [bp-53C0h]@5
  char v49; // [sp+A8h] [bp-53BCh]@5
  char v50; // [sp+A9h] [bp-53BBh]@5
  char v51; // [sp+ACh] [bp-53B8h]@5
  char v52; // [sp+B0h] [bp-53B4h]@5
  char v53; // [sp+C0h] [bp-53A4h]@5
  char v54; // [sp+C1h] [bp-53A3h]@5
  char v55; // [sp+C4h] [bp-53A0h]@5
  char v56; // [sp+C8h] [bp-539Ch]@5
  char v57; // [sp+C9h] [bp-539Bh]@5
  char v58; // [sp+E8h] [bp-537Ch]@5
  char v59; // [sp+ECh] [bp-5378h]@5
  char v60; // [sp+F0h] [bp-5374h]@5
  char v61; // [sp+F1h] [bp-5373h]@5
  char v62; // [sp+F4h] [bp-5370h]@5
  char v63; // [sp+FCh] [bp-5368h]@5
  char v64; // [sp+100h] [bp-5364h]@5
  char v65; // [sp+108h] [bp-535Ch]@5
  char v66; // [sp+40Ch] [bp-5058h]@5
  char v67; // [sp+40Dh] [bp-5057h]@5
  char v68[19528]; // [sp+410h] [bp-5054h]@6
  char v69; // [sp+5058h] [bp-40Ch]@3
  char v70; // [sp+5059h] [bp-40Bh]@3
  char v71; // [sp+5258h] [bp-20Ch]@3
  char v72; // [sp+5259h] [bp-20Bh]@3
  WCHAR SubKey; // [sp+5358h] [bp-10Ch]@4
  char v74; // [sp+535Ah] [bp-10Ah]@4

  v3 = a2;
  pDataIn.pbData = a3;
  v4 = a2;
  v5 = a1;
  v29 = 0;
  v6 = (int)(a2 + 1);
  do
  {
    v7 = *v4;
    ++v4;
  }
  while ( v7 );
  pDataOut.pbData = (BYTE *)(((signed int)v4 - v6) >> 1);
  v8 = wcslen(v5);
  v69 = 0;
  memset(&v70, 0, 0x1FFu);
  v71 = 0;
  memset(&v72, 0, 0xFFu);
  wcstombs(&v69, v3, 0x200u);
  wcstombs(&v71, v5, 0x100u);
  if ( RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Wlansvc\\", 0, 0xF013Fu, &phkResult) )
  {
    wprintf(L"failed to open subkey '%s'\n", L"SOFTWARE\\Microsoft\\Wlansvc\\");
  }
  else
  {
    memset(&v32, 0, 0x5000u);
    SubKey = 0;
    memset(&v74, 0, 0xFEu);
    sub_401000(v9, &SubKey);
    if ( !RegCreateKeyExW(phkResult, &SubKey, 0, 0, 0, 0xF013Fu, 0, &hKey, 0) )
    {
      v10 = v8 + 1;
      v34 = (16 * ((v10 >> 4) + 11) >> 8) + 4;
      v38 = (16 * ((v10 >> 4) + 11) >> 8) + 4;
      v33 = 16 * ((v10 >> 4) + 11);
      v37 = 16 * ((v10 >> 4) + 11);
      v11 = 16 * (v10 >> 4);
      v44 = 16 * ((v10 >> 4) + 9);
      v45 = (16 * ((v10 >> 4) + 9) >> 8) + 4;
      v40 = v11 + 108;
      v49 = v11 + 76;
      v31 = 16 * (v10 >> 4);
      v42 = 32;
      v51 = 32;
      v64 = 32;
      v60 = v11 + 16;
      v53 = v11 + 56;
      v56 = v11 + 56;
      v35 = 24;
      v36 = 2;
      v39 = 1;
      v41 = 4;
      v43 = 28;
      v46 = 1;
      v47 = 25;
      v48 = 2;
      v50 = 4;
      v52 = 25;
      v54 = 4;
      v55 = 2;
      v57 = 4;
      v58 = 1;
      v59 = 1;
      v61 = 4;
      v62 = 26;
      v63 = 3;
      memcpy(&v65, &v69, (size_t)pDataOut.pbData);
      v66 = v31 - 26;
      v67 = (unsigned __int16)(16 * (v10 >> 4) + 230) >> 8;
      pDataIn.pbData = (BYTE *)&v71;
      pDataIn.cbData = v10;
      if ( CryptProtectData(&pDataIn, 0, 0, 0, 0, 4u, &pDataOut) )
      {
        v12 = pDataOut.cbData;
        memcpy(v68, pDataOut.pbData, pDataOut.cbData);
        v18 = 0;
        v19 = 0;
        v20 = 83951616;
        v21 = 0;
        v22 = 1377536;
        v23 = -777715712;
        v24 = -459921065;
        v25 = -1609026490;
        v26 = 65596740;
        v27 = 0;
        v28 = 0;
        qmemcpy(&v68[v12], &v18, 0x28u);
        v13 = pDataOut.pbData;
        *(_WORD *)&v68[v12 + 40] = v28;
        LocalFree(v13);
        pDataIn.pbData = (BYTE *)&v32;
        pDataIn.cbData = pDataOut.cbData + 994;
        if ( CryptProtectData(&pDataIn, 0, 0, 0, 0, 0, &pDataOut) )
        {
          if ( !RegSetKeyValueW(hKey, 0, L"MSMUserData", 3, pDataOut.pbData, pDataOut.cbData) )
            v29 = 1;
          LocalFree(pDataOut.pbData);
        }
      }
      else
      {
        wprintf(L"failed to encrypt credential password. UserEapInfo does not save\n");
      }
    }
    if ( RegCloseKey(hKey) || RegCloseKey(phkResult) )
    {
      wprintf(L"Can't close registry\n");
      return v29;
    }
  }
  return v29;
}